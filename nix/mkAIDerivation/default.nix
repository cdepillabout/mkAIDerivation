
{ callPackage
, evilDownloadUrl
, fetchurl
, lib
}:

prompt:

let
  # The URL to use to access the ai-drv-server.
  # By default the ai-drv-server runs on localhost on port 5000.
  # You'll need to change this if you run it somewhere else.
  ai-drv-server-url = "http://127.0.0.1:5000";

  # The URL to use to get the hash of the derivation.
  #
  # Accessing this URL will internally call the OpenAI API to generate
  # a derivation, the store it locally.  The result of this call will be
  # the hash of the generated derivation, so that we can use an FOD to
  # later fetch it.
  #
  # hash-url :: String
  hash-url = "${ai-drv-server-url}/hash?req=${lib.escapeURL prompt}";

  # The result of calling `hash-url`.  This uses evilDownloadUrl, so
  # it gets (im)pure network access.
  #
  # hash-drv :: Derivation
  hash-drv = evilDownloadUrl hash-url;

  # hash-drv is just a file that contains the hash of the derivation generated
  # by OpenAI.  so we use IFD to read it here.
  #
  # hash :: String
  hash = builtins.readFile hash-drv;

  # The raw text of the derivation generated by OpenAI.  Use the (im)purely
  # fetched hash to fetch it with an FOD.  This should be valid nix code
  # (assuming the LLM generated code for us correctly).
  #
  # raw-drv :: Derivation
  raw-drv = fetchurl {
    url = "${ai-drv-server-url}/drv?hash=${lib.escapeURL hash}";
    sha256 = "sha256-${hash}";
  };

  # Call the raw derivation text with callPackage.  This completes the process
  # and gives us the actual fully-generated derivation
  #
  # drv :: Derivation
  drv = callPackage raw-drv {};
in

# Add the passthru.mkAIDerivation attributes to the drv to make the underlying
# LLM-generated raw Nix code easily inspectable.
drv.overrideAttrs
  (oldAttrs:
    let
      old-passthru = oldAttrs.passthru or {};
      old-mkAIDerivation = old-passthru.mkAIDerivation or {};
    in
    {
      passthru = old-passthru // {
        mkAIDerivation = old-mkAIDerivation // {
          inherit hash prompt raw-drv;
        };
      };
    }
  )
